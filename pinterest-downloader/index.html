<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinterest Media Downloader</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .container {
            max-width: 600px;
            margin: auto;
        }
        input, button {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            font-size: 16px;
        }
        .result {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Pinterest Media Downloader</h1>
    <input type="text" id="urlInput" placeholder="Введите URL пина Pinterest">
    <input type="text" id="outputDir" placeholder="Введите путь для сохранения (по умолчанию текущая директория)">
    <button id="downloadButton">Скачать</button>
    <div class="result" id="result"></div>
</div>

<script>
    document.getElementById('downloadButton').addEventListener('click', async () => {
        const url = document.getElementById('urlInput').value.trim();
        const outDir = document.getElementById('outputDir').value.trim() || '.';
        const resultDiv = document.getElementById('result');
        resultDiv.textContent = 'Загрузка...';

        try {
            // Валидация URL
            validateUrl(url);

            // Получение медиафайла
            const mediaResult = await downloadPinterestMedia(url, outDir);
            if (mediaResult.success) {
                resultDiv.innerHTML = `<strong>Успех:</strong> Тип: ${mediaResult.type}, Файл: ${mediaResult.file_path}`;
            } else {
                resultDiv.innerHTML = `<strong>Ошибка:</strong> ${mediaResult.error}`;
            }
        } catch (error) {
            resultDiv.innerHTML = `<strong>Ошибка:</strong> ${error.message}`;
        }
    });

    function validateUrl(url) {
        try {
            const parsed = new URL(url);
            if (!['http:', 'https:'].includes(parsed.protocol)) {
                throw new Error('Только HTTP/HTTPS URL разрешены');
            }
        } catch (e) {
            throw new Error('Неверный URL');
        }
    }

    function sanitizeFilename(filename) {
        return filename.replace(/[<>:"/\\|?*]/g, '_');
    }

    function generateUniqueFilename(url, ext) {
        const hashName = md5(url); // Используем библиотеку CryptoJS для хэширования
        return `pinterest_media_${hashName}.${ext}`;
    }

    async function downloadPinterestMedia(url, outDir) {
        try {
            // HEAD-запрос для определения конечного URL
            const finalUrl = await getFinalUrl(url);

            // GET-запрос для получения HTML-контента
            const page = await fetchPageContent(finalUrl);

            // Поиск ссылки на видео
            const videoMatch = page.match(/"contentUrl"\s*:\s*"([^"]+\.mp4[^"]*)"/);
            if (videoMatch) {
                const vidUrl = videoMatch[1].replace(/\\u002F/g, '/').replace(/\\/g, '');
                const vidData = await fetchMedia(vidUrl);
                const ext = vidUrl.split('.').pop().split('?')[0];
                const fname = generateUniqueFilename(vidUrl, ext);
                const fpath = `${outDir}/${sanitizeFilename(fname)}`;
                await saveFile(fpath, vidData);
                return { success: true, type: 'video', file_path: fpath };
            }

            // Поиск ссылки на изображение
            const imgMatch = page.match(/https:\/\/i\.pinimg\.com\/originals\/[^"]+/);
            if (imgMatch) {
                const imgData = await fetchMedia(imgMatch[0]);
                const ext = imgMatch[0].split('.').pop().split('?')[0];
                const fname = generateUniqueFilename(imgMatch[0], ext);
                const fpath = `${outDir}/${sanitizeFilename(fname)}`;
                await saveFile(fpath, imgData);
                return { success: true, type: 'image', file_path: fpath };
            }

            return { success: false, error: 'Медиа не найдено' };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    async function getFinalUrl(url) {
        const response = await fetch(url, { method: 'HEAD', redirect: 'follow' });
        return response.url;
    }

    async function fetchPageContent(url) {
        const response = await fetch(url, { method: 'GET', headers: { 'User-Agent': 'Mozilla/5.0' } });
        return await response.text();
    }

    async function fetchMedia(url) {
        const response = await fetch(url, { method: 'GET', headers: { 'User-Agent': 'Mozilla/5.0' } });
        return await response.arrayBuffer();
    }

    async function saveFile(filePath, data) {
        const blob = new Blob([data], { type: 'application/octet-stream' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filePath.split('/').pop();
        link.click();
    }

    // Простая реализация MD5 через CryptoJS
    function md5(str) {
        const crypto = window.crypto || window.msCrypto;
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        return crypto.subtle.digest('MD5', data).then(hash => {
            let hex = '';
            const view = new DataView(hash);
            for (let i = 0; i < view.byteLength; i += 4) {
                hex += ('00000000' + view.getUint32(i).toString(16)).slice(-8);
            }
            return hex;
        });
    }
</script>
</body>
</html>
